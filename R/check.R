#' function to check whether `type` arg is supplied correctly to `collapse()` or
#' `compute()`
#' @importFrom rlang abort
#' @noRd
#' @keywords Internal
check_type <- function(.data, type, what){
  if(missing(what)){
    if(!any(names(.data) == "what")){
      abort("error in `check_type`; `what` is unknown")
    }
  }else{
    .data$what <- what
  }
  if(missing(type)){
    if(!any(names(.data) == "type")){
      .data$type <- switch(.data$what, 
             "media" = "Image",
             "records")      
    }
  }else{
    .data$type <- type
  }
  .data
}

#' function to check whether `what` arg is supplied to `collapse()` or `compute()`
#' @importFrom rlang abort
#' @noRd
#' @keywords Internal
check_what <- function(what){
  if(missing(what)){
    bullets <- c("Argument `what` is missing, with no default",
                 i = "`what` must be one of 'counts', 'species', 'occurrences' or 'media'")
    abort(bullets)
  }
}

#' Internal function to confirm requisite login information has been provided
#' Called by `compute()`
#' @noRd
#' @keywords Internal
#' @importFrom rlang caller_env
check_login <- function(.data, error_call = caller_env()){
  if(is_gbif()){
    if(.data$opts$userpwd == ":"){
      abort("GBIF requires a username and password to download occurrences or species")
    }
  }else{
    if(.data$query$email == ""){
      bullets <- c(
        "No user email was found.",
        i = glue("To download occurrence records you must provide a valid email ",
                 "address registered with the selected atlas using `galah_config(email = )`")
      )
      abort(bullets, call = error_call)
    }
  }
}

#' Check whether geolocate functions have >1 argument
#' @noRd
#' @keywords Internal
check_n_inputs <- function(dots, error_call = caller_env()) {
  if(length(dots) > 1){
    n_geolocations <- length(dots)
    bullets <- c(
      "More than 1 spatial area provided.",
      "*" = glue("Using first location, ignoring additional {n_geolocations - 1} location(s).")
    )
    warn(bullets, call = caller_env())
  }
}

# Check taxonomic argument provided to `atlas_` functions is of correct form
check_taxa_arg <- function(taxa, error_call = caller_env()) {
  # if (!any(grepl("id", class(taxa)))) {
  if(!inherits(taxa, "galah_identify")){
    if (!any(grepl("\\d", taxa))) {
      bullets <- c(
        "Wrong type of input provided to `identify` argument.",
        i = glue("`identify` requires an identifier input generated by \\
        `galah_identify`.")
      )
      abort(bullets, call = error_call)
    }
  }
}

check_data_request <- function(request, error_call = caller_env()){
  if(!inherits(request, "data_request")){
    bullets <- c(
      "Argument `request` requires an object of type `data_request`.",
      i = "You can create this object using `galah_call()`",
      i = "Did you specify the incorrect argument?"
    )
    abort(bullets, call = caller_env())      
  }     
}

# Check for valid `type`
check_type_valid <- function(type, valid, error_call = caller_env()) {
  if(!any(valid == type)){
    bullets <- c(
      glue("type `{type}` is not recognised"),
      i = "see ?show_all for a list of valid information types."
    )
    abort(bullets, call = error_call)   
  }
}

check_named_input <- function(dots){
  name_length <- any(length(names(dots) > 0)) & any(names(dots) != "")
  if(name_length){
    bullets <- c(
      "We detected a named input.",
      i = "This usually means that you've used `=` instead of `==`.")
    abort(bullets)
  }
}

# If no args are supplied, set default columns returned as group = "basic"
check_groups <- function(group, n){
  if(missing(group)){
    if(n < 1){
      "basic"
    }else{
      NULL
    }
  }else{
    match.arg(group, 
              choices = c("basic", "event", "media", "assertions"),
              several.ok = TRUE)
  }
}