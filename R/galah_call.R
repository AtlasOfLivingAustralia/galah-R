#' Start to build a data query
#' 
#' To download data from the ALA (or another atlas), one must construct a data 
#' query. This query tells the atlas API what data to download and return, as 
#' well as how it should be filtered. The `galah` package enables users to 
#' construct their data queries using piping syntax (i.e., `%>%` from `magrittr`, 
#' or `|>` from `base`). Building a data query using piping allows users to use 
#' functions like [search_taxa()], [galah_filter()], `[galah_select()]`, 
#' [galah_group_by()], and [galah_down_to()] to specify filters for their 
#' queries line-by-line, narrowing the results of their query. 
#' Users then finish their query with an `atlas_` function to identify which 
#' type of data they wish to download (i.e., [atlas_occurrences()], 
#' [atlas_counts()], [atlas_species()], [atlas_taxonomy()] or [atlas_media()]).
#' 
#' @param taxa `data.frame`: generated by a call to [search_taxa()]. This
#' argument also accepts a vector of unique species identifiers.
#' @param filter `data.frame`: generated by a call to [select_filters()]
#' @param select `data.frame`: generated by a call to [galah_select()]
#' @param geolocate `string`: generated by a call to [galah_geolocate()]
#' @param group_by `data.frame`: generated by a call to [galah_group_by()]
#' @param down_to `data.frame`: generated by a call to [galah_down_to()]
#' @param ... other function-specific request parameters
#' 
#' @examples 
#' \dontrun{
#' # Find number of records of Aves from 2001 to 2004 by year
#' galah_call() |>
#'   search_taxa("Aves") |>
#'   galah_filter(year > 2000 & year < 2005) |>
#'   galah_group_by() |>
#'   atlas_counts()
#'   
#' # Download Eolophus records from 2001 to 2004
#' galah_call() |>
#'   search_taxa("Eolophus") |>
#'   galah_filter(year > 2000 & year < 2005) |>
#'   atlas_occurrences()
#'   
#' # Find information for all species in Cacatuidae family
#' galah_call() |>
#'   search_taxa("Cacatuidae") |>
#'   atlas_species()
#' }
#' @export galah_call
galah_call <- function(taxa = NULL, 
                       filter = NULL, 
                       select = NULL,
                       geolocate = NULL, 
                       group_by = NULL,
                       down_to = NULL,
                       ...){
  
  extra_args <- list(...)
  
  if(!is.null(taxa)){ check_taxa_arg(taxa) }
  check_call_args(filter, "filter")
  check_call_args(select, "select")
  check_call_args(geolocate, "geolocate")
  check_call_args(group_by, "group_by")
  check_call_args(down_to, "down_to")
  
  request <- structure(c(list(taxa = taxa,
                              select = select, 
                              filter = filter,
                              geolocate = geolocate,
                              group_by = group_by,
                              down_to = down_to),
                         extra_args),
                       class = "data_request")
  
  return(request)
}


check_call_args <- function(arg_supplied, arg_name){
  if(
    !is.null(arg_supplied) && 
    !inherits(arg_supplied, paste0("galah_", arg_name))
  ){
    abort(
      glue("`{arg_name}` argument requires an input generated by `galah_{arg_name}()`"),
      call = caller_env()
    )
  }
}


update_galah_call <- function(data_request, ...){
  dots <- list(...)
  result <- lapply(
    names(data_request), 
    function(a){
      if(any(names(dots) == a)){
        if(is.null(data_request[[a]])){
          dots[[a]]
        }else{
          removed_class <- class(data_request[[a]])[4]
          class(data_request[[a]]) <- class(data_request[[a]])[1:3]
          class(dots[[a]]) <- class(dots[[a]])[1:3]
          set_galah_object_class(
            rbindlist(list(data_request[[a]], dots[[a]]), fill = TRUE),
            class = removed_class)        
        }
      }else{
        data_request[[a]]
      }
    })
  names(result) <- names(data_request)
  
  # check if any names in `dots` have been missed from `results`
  missing_names <- !(names(dots) %in% names(result))
  if(any(missing_names)){
    result <- append(result, dots[missing_names])
  }
  class(result) <- "data_request"
  result
}


#' @rdname galah_call
#' @name galah_call
#' @keywords internal
#' @export
print.data_request <- function(object){
  filled_slots <- !unlist(lapply(object, is.null))
  if(any(filled_slots)){
    cat("An object of type `data_request` containing:\n\n")
    print(as.list(object[filled_slots]))
  }else{
    cat("An empty object of type `data_request`")
  }
}


# function used in `galah_` and `search_` functions to determine 
# whether a quosure list contains an object of class `data_request`
# as its' first argument
detect_data_request <- function(dots){
  is_either <- (is_function_check(dots) | is_object_check(dots))
  if(length(is_either) < 1){
    is_either <- FALSE
  }else{
    is_either <- is_either[[1]]
  }
  if(is_either){
    eval_result <- try({eval_tidy(dots[[1]])}, silent = TRUE)
    if(inherits(eval_result, "try-error")){
      return(dots)
    }else if(inherits(eval_result, "data_request")){
      return(list(
        data_request = eval_result,
        dots = dots[-1]
      ))
    }else{
      return(dots)
    }
  }else{
    return(dots)
  }  
}