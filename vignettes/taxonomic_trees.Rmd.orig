---
title: "Taxonomic trees"
author: "Martin Westgate, Dax Kellie & Matilda Stevenson"
date: '`r Sys.Date()`'
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Taxonomic trees}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
  


  ## Taxonomic trees
  `atlas_taxonomy` provides a way to build taxonomic trees from one clade down to 
  another using ALA's internal taxonomy. Specify which taxonomic level your tree 
  will go down to with `galah_down_to`.
  ```{r}
  # Taxonomic tree of Fungi to phylum level
  atlas_taxonomy(taxa = search_taxa("fungi"),
                 down_to = galah_down_to(phylum))
  ```

  As of `galah` 1.4.0, you can also do the same as above by piping with `%>%` 
  or `|>`:
  ```{r warning = FALSE}
  library(magrittr)

  galah_call() %>%
    search_taxa("fungi") %>%
    galah_down_to(phylum) %>%
    atlas_taxonomy()
  ```



## Taxonomic trees

While many users want to restrict searches to particular taxa using `search_taxa()`,
there are many cases where the taxonoimc hierarchy is itself the parameter of 
investigation. In that case you can return taxonomic information as a tree
(from package `data.tree`) using `atlas_taxonomy()`. This function requires 
two arguments:
  
  - `taxa` supplies the higher taxonomic group for which data is required
  - `down_to` is the lowest rank of the taxonomic hierarchy that the user requires (see `show_all_ranks()` for valid options)

The function then searches 'downwards' from `taxa` to build the tree.


```{r search}
library(data.tree)
classes <- atlas_taxonomy(taxa = search_taxa("Chordata"), 
                          down_to = galah_down_to(class))
print(classes, "rank")
```


Note that if you are traversing more than 3 ranks, it might be more efficient
to use `atlas_species`, as `atlas_taxonomy` is inefficient when the search tree
is large.

### Manipulating trees

The `data.tree` package is quite rich and contains many useful functions, so we
won't attempt to give a complete overview here. Nonetheless, there are some useful
functions that might be of particular interest. A clear example is 'pruning' the tree,
for example by only retaining nodes that are from the same source (or 'authority').

```{r prune}
unique(classes$Get("authority")) # levels available in the dataset

# subset to only those nodes supplied by the Australian Faunal Directory
Prune(classes, pruneFun = function(a){a$authority == "AFD"})
print(classes, "authority")
```

Note that the above syntax is slightly unusual, in that the tree 
(`classes`) is updated even though we don't assign the result to an obect. 
This is because `classes` is an `R6` object. In fact, trees created from 
`data.tree` Nodes have a few unusual properties that we can exploit to do 
interesting things. A common task, for example, is to calculate the number of 
records present for each node in the tree. A quick way to do this would be to 
extract all the `guid` values and query them using `atlas_counts()`.
  
```{r all-counts}
counts <- lapply(classes$Get("guid"), atlas_counts)
```

While this approach works, it is inefficient, because each node has to be searched
separately. A more efficient solution is to recognise that counts for higher 
taxonomic groups/nodes should be the sum of their child nodes. We can use this 
logic to run fewer queries via the ALA, and thereby get a neater result in less time.


```{r leaf-counts}
# select only the 'leaves' (terminal nodes) of the tree
leaves <- Traverse(classes, filterFun = isLeaf)

# get data on record counts
leaf_counts <- lapply(Get(leaves, "guid"), atlas_counts)

# add back on to the tree
classes$Set(n_records = 0)
Set(leaves, n_records = unlist(leaf_counts))
print(classes, "n_records")

# sum upwards
classes$Do(
  function(a){
    a$n_records <- Aggregate(node = a, attribute = "n_records", aggFun = sum)},
  traversal = "post-order")
print(classes, "n_records")
```

The same approach can be used to find the number of species within a clade
```{r species-counts}
# get species counts
leaf_spp_counts <- lapply(
  Get(leaves, "guid"),
  function(x){atlas_counts(taxa = x, type = "species")})

# add back to the tree, then sum
classes$Set(n_species = 0)
Set(leaves, n_species = unlist(leaf_spp_counts))
classes$Do(
  function(a){
    a$n_species <- Aggregate(node = a, attribute = "n_species", aggFun = sum)},
  traversal = "post-order")
  
# check results
print(classes, "n_species")
```

### Conversion

Although the tree format is useful, converting to a `data.frame` 
is straightforward.

```{r to-df}
# arrange columns by 'level'
ToDataFrameTypeCol(classes) 

# arrange columns by 'rank'
ToDataFrameTypeCol(classes, type = "rank") # works, but merges informal ranks

```

While useful, neither of the above approaches preserve the rank of each node if
there are multiple nodes in the `data.tree` returned with rank `informal` or 
`unranked`. Therefore, a more useful approach is to take more care in linking 
levels and ranks, then converting to a `data.frame`

```{r to-df-advanced}
# create a label that uniquely identifies unranked nodes
classes$Do(
  function(a){
    if(a$rank %in% show_all_ranks()$name){
      a$rank_level <- a$rank
    }else{
      a$rank_level <- paste0(a$rank, "-level-", a$level)
    }
  })

# use rank_level as an index to create a data.frame
df <- ToDataFrameTypeCol(classes, type = "rank_level", prefix = NULL)
df
```

If we want to take more information out of the tree, we can extract it 
and append to our new `data.frame`.

```{r add-columns}
cbind(
  df[, c("phylum", "subphylum", "class")],
  data.frame(
    auth = ToDataFrameTypeCol(classes, "authority")$authority))
```

###  Visualisation

There are a range of methods for visualising objects returned by `data.tree`. 
The `tidygraph` package can be used to convert a tree into a format suitable for 
plotting with `ggraph`.

```{r ggraph, eval = FALSE}
library(ggplot2)
library(tidygraph)
library(ggraph)

ggraph(as_tbl_graph(classes), layout = 'dendrogram') +
  geom_edge_elbow() + 
  geom_node_label(aes(label = name), hjust = 0) +
  coord_flip() +
  scale_y_reverse(expand = expansion(add = 2)) +
  theme_void() 
```
<img src="taxonomic_information-ggraph-1.png" title="plot of chunk ggraph" alt="plot of chunk ggraph" width="100%" />

Alternatively, the `collapsibleTree` package works on a `data.frame`.

```{r collapsible-tree, eval = FALSE}
library(collapsibleTree)
collapsibleTree(
  df,
  hierarchy = colnames(df),
  root = "Chordata",
  collapsed = FALSE,
  width = 700,
  height = 400)
```
<!-- A static image of the plot to avoid CRAN phantomjs() conflicts -->
<img src="taxonomic_information-collapsible-tree-1.png" title="plot of chunk collapsible-tree" alt="plot of chunk collapsible-tree" width="100%" />
