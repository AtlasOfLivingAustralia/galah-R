---
title: "Quick start guide"
author: "Martin Westgate & Dax Kellie"
date: '`r Sys.Date()`'
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quick start guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
`galah` is an R interface to biodiversity data hosted by the Global Biodiversity 
Information Facility ([GBIF](https://www.gbif.org)) and its subsidiary node
organisations. GBIF and its partner nodes collate and store observations of 
individual life forms using the ['Darwin Core'](https://dwc.tdwg.org) data 
standard.

# Installation

To install from CRAN:
```{r, cran-install, eval=FALSE}
install.packages("galah")
```

Or install the development version from GitHub:
```{r, remotes-install, eval=FALSE}
install.packages("remotes")
remotes::install_github("AtlasOfLivingAustralia/galah")
```

Load the package
```{r, load-package, eval=FALSE}
library(galah)
```

# Configuration
Begin by choosing which organisation you would like `galah` to query,
and providing your registration information for that organisation.

```{r, galah-config, eval=FALSE}
galah_config(atlas = "GBIF",
             username = "user1",
             email = "email@email.com",
             password = "my_password")

```

The full list of supported queries by organisation is as follows:

```{r, atlas-support, echo = FALSE, out.width = "100%", fig.cap="Fig 1: Organisations and APIs supported by galah"}
knitr::include_graphics('../man/figures/atlases_plot.png')
```

# Getting data
`galah` is a `dplyr` extension package; rather than using pipes to amend 
a `tibble` in your workspace, you amend a query, which is then sent to your
chosen organisation. These pipes differ from traditional syntax in two ways:

- they begin with a function - usually `galah_call()` - instead of a `tibble`
- they end with one of `dplyr`'s evaluation functions, usually `collect()`

So an example query might be to find the number of records per year:

```{r, count-example}
galah_config(atlas = "Australia")

galah_call() |>            # open a pipe
  filter(year >= 2020) |>  # choose rows to keep
  count(year) |>           # count the number of rows
  collect()                # retrieve query from the server
```

Or to find the number of categories present in a dataset, for example how many 
species are present:

```{r, distinct-example}
galah_call() |>
  identify("Crinia") |>   # filters by taxonomic names
  distinct(speciesID) |>  # keep only unique values
  count() |>
  collect()
```

You can 'glimpse' a data download before you run it, to check all the data 
you need is included:

```{r, glimpse-example}
galah_call() |>
  identify("Eolophus roseicapilla") |> 
  filter(year == 2010) |>
  glimpse() |>
  collect()
```

And, once satisfied that your parameters are correct, download the records 
themselves:

```{r, cache-email, echo = FALSE}
galah_config(email = "ala4r@ala.org.au",
             verbose = FALSE)
```

```{r, occurrence-example, message = FALSE}
galah_call() |>
  identify("Eolophus roseicapilla") |> 
  filter(year == 2010) |>
  select(eventDate, decimalLatitude, species) |>
  collect()
```

This works because many of the functions in `dplyr` are "generic", meaning
it is possible to write extensions that apply them to new object classes. 
In our case, `galah_call()` creates a new object class called a 
`data_request` for which we have written new extensions. This means that galah 
will not interfere with your use of `filter()` and friends on your tibbles.
Supported `dplyr` verbs that modify queries are as follows:

- `arrange.data_request()`
- `count.data_request()`
- `distinct.data_request()`
- `filter.data_request()`
- `glimpse.data_request()`
- `group_by.data_request()`
- `select.data_request()`
- `slice_head.data_request()`

Additional verbs are: 

- `apply_profile()`
- `geolocate()` or `st_crop.data_request()`
- `identify.data_request()`
- `unnest()`

It is good practice to download your data in as few steps as possible,
to minimize impacts on the server, and to ensure you can get a single
DOI for your data. See the 
[download data reproducibly](download-data-reproducibly.html) vignette 
for details.

# Finding information

Building queries using `filter()` requires that you know two things:

- what **fields** (columns) are present in the dataset you are searching
- what **values** exist for those fields

Finding this information requires looking for metadata:

```{r, metadata-fields}
request_metadata(type = "fields") |>
  collect()
```

You can browser this tibble using `View()` or search it using `filter()`.
Once you have found a field that you want to include in your query, you 
can find values for that field using `unnest()`:

```{r, metadata-fields-unnest}
request_metadata() |>
  filter(fields == "cl22") |>
  unnest() |>
  collect()
```

Different types of metadata are available; see `?request_metadata` for
a full list.

# Wrapper functions

While `dplyr` syntax is very flexible, there are cases where it is easier 
to simply say the sort of data you want, rather than create a database
query to implement it. For this reason, several common use cases have
their own wrapper functions.

The `atlas_` family of functions act like `collect()`, but enforce
a particular type of data to be returned, such as record counts:

```{r, atlas-counts}
galah_call() |>
  filter(year == 2025) |>
  atlas_counts()   # note no need for a `count()` function
```

Or occurrences:

```{r, atlas-occurrences, message = FALSE}
galah_call() |>
  identify("Eolophus roseicapilla") |>
  filter(year == 2000,
         cl22 == "Australian Capital Territory") |>
  atlas_occurrences() |>
  print(n = 6)
```

`atlas_species()` replaces the need for `distinct()` call, while `atlas_media()`
is a shortcut to a complex workflow that incorporates both data and metadata
calls; see the [downloading images and sounds](downloading_images_and_sounds.html)
vignette for details.

Finally, metadata calls can be made more efficiently using the `show_all()` 
and `show_values()` functions. These take the same arguments as the `type`
argument in `request_metadata()`, but use non-standard evaluation, so they
don't require quotes. They are also evaluated immediately rather than lazily:

```{r, show-all-fields}
show_all(fields)
```

You can check the [look up information](lookup_up_information.html) vignette 
for further details.

