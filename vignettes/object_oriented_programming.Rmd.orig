---
title: "Object-Oriented Programming in galah"
author: "Martin Westgate"
date: '`r Sys.Date()`'
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Object-Oriented Programming in galah}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r include = FALSE}
galah_config(email = "ala4r@ala.org.au",
             atlas = "Australia", 
             caching = FALSE, 
             verbose = FALSE)
```

From version 2.0 onwards, `galah` is built around object-oriented programming 
principles. In practice, this won't change the experience for most users. 
However, it does enable new ways of programming that were not previously 
available. 

When requesting data from `galah`, you can begin your pipe with a dedicated
function depending on the type of data you want to collect. For example, if you
want to get occurrences, use `request_data()`:

```{r}
x <- request_data() |>
  filter(genus == "Crinia", year == 2020) |>
  group_by(species) |>
  count()
```
This call creates an object of class `data_request` for which several methods 
are available, typically masked from `dplyr`, which is why `filter` and
`group_by` are possible in the code block above. The full list of masked 
functions is: 

- `arrange()` (`{dplyr}`)
- `count()` (`{dplyr}`)
- `identify()` (`{graphics}`) as a synonym for `galah_identify()`
- `select()` (`{dplyr}`) as a synonym for `galah_select()`
- `group_by()` (`{dplyr}`) as a synonym for `galah_group_by()`
- `slice_head()` (`{dplyr}`) as a synonym for the `limit` argument in `atlas_counts()`
- `st_crop()` (`{sf}`) as a synonym for `galah_polygon()`

Note that these functions are all evaluated lazily; they amend the underlying 
object, but do not amend the nature of the data until the call is evaluated.
To actually build and run the query, we use one or more of a different set of
 `{dplyr}` verbs:

- `collapse()` converts the object to query so you can inspect your API calls
- `compute()` does any further computation that requires pinging an API, such
  as sending a query or determining how much pagination is needed
- `collect()` returns a `tibble()` with the requested data

We can use these in sequence, or just leap ahead to the stage we want:

```{r}
collapse(x) |> str()

collect(x)
```

Under the hood, these verbs amend our object to a new class:

- `request_data()` returns class `data_request`
- `collapse()` returns class `data_query`
- `compute()` returns class `data_response`
- `collapse()` doesn't add a new data class (returns class `tibble`)


## All `galah` object classes
In practice, there are actually 12 new classes:

- `request_data()` generates `data_request`, followed by `data_query` and `data_response`
- `request_files()` generates `files_request`, followed by `files_query` and `files_response`
- `request_metadata()` generates `metadata_request`, followed by `metadata_query` and `metadata_response`
- `request_values()` generates `values_request`, followed by `values_query` and `values_response`

_this needs a table or diagram or something_

_give examples of files, metadata and values_

These can be called directly, or via the `method` argument of `galah_call()`, 
which is used to specify the suffix to the `request_` call, defaulting to 
`"data"`. That is, the following calls are synonymous:

```{r, eval = FALSE}
request_data() |>
  filter(year == 2020) |>
  count() |>
  collect()

galah_call() |>
  galah_filter(year == 2020) |>
  atlas_counts()
```

_give example of using `galah_call()` with a different `method` arg

## Benefits 
What are the benefits of this new method? We see several:

- Splitting `atlas_` functions up into `collapse`, `compute` and `collect` stages
  makes them more modular; you can now submit a query and download it later,
  without having to wait for it to finish.
- Previously some functions did several different things, making it difficult
  to know which APIs were being called, when, and for what purpose. This is 
  much more transparent in the new framework.
- Functions that are more modular are generally easier to interrogate and debug

_expand the above points with examples_

Despite these benefits, we have no plans to _require_ this new syntax; functions
prefixed with `galah_` or `atlas_` are not going away. Indeed while there is 
perfect redundancy between old and new syntax in some cases, in others they
serve different purposes. In `atlas_media()` for example, several calls 
are made and joined in a way that reduces the number of steps required by the 
user (_expand this exampple_)

Under the hood, however, all `atlas_` functions are now entirely built using the 
above syntax.