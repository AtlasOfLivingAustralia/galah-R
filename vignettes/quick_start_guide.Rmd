---
title: "Quick start guide"
author: "Martin Westgate & Dax Kellie"
date: '2026-01-08'
output:
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quick start guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
`galah` is an R interface to biodiversity data hosted by the Global Biodiversity 
Information Facility ([GBIF](https://www.gbif.org)) and its subsidiary node
organisations. GBIF and its partner nodes collate and store observations of 
individual life forms using the ['Darwin Core'](https://dwc.tdwg.org) data 
standard.

# Installation

To install from CRAN:

``` r
install.packages("galah")
```

Or install the development version from GitHub:

``` r
install.packages("remotes")
remotes::install_github("AtlasOfLivingAustralia/galah")
```

Load the package

``` r
library(galah)
```

# Configuration
Begin by choosing which organisation you would like `galah` to query,
and providing your registration information for that organisation.


``` r
galah_config(atlas = "GBIF",
             username = "user1",
             email = "email@email.com",
             password = "my_password")
```

The full list of supported queries by organisation is as follows:

<div class="figure">
<img src="../man/figures/atlases_plot.png" alt="Organisations supported by galah" width="100%" />
<p class="caption">Organisations supported by galah</p>
</div>

# Getting data
`galah` is a `dplyr` extension package; rather than using pipes to amend 
a `tibble` in your workspace, you amend a query, which is then sent to your
chosen organisation. These pipes differ from traditional syntax in two ways:

- they begin with a function - usually `galah_call()` - instead of a `tibble`
- they end with one of `dplyr`'s evaluation functions, usually `collect()`

So an example query might be to find the number of records per year:


``` r
galah_config(atlas = "Australia")

galah_call() |>            # open a pipe
  filter(year >= 2020) |>  # choose rows to keep
  count(year) |>           # count the number of rows
  collect()                # retrieve query from the server
```

```
## # A tibble: 7 × 2
##   year     count
##   <chr>    <int>
## 1 2024  11770412
## 2 2023  10974292
## 3 2022   9422565
## 4 2025   8989765
## 5 2021   8686097
## 6 2020   7308421
## 7 2026     26191
```

Or to find the number of categories present in a dataset, for example how many 
species are present:


``` r
galah_call() |>
  identify("Crinia") |>   # filters by taxonomic names
  distinct(speciesID) |>  # keep only unique values
  count() |>
  collect()
```

```
## # A tibble: 1 × 1
##   count
##   <int>
## 1    17
```

Or to download the records themselves:




``` r
galah_call() |>
  identify("Eolophus roseicapilla") |> 
  filter(year == 2010) |>
  select(eventDate, decimalLatitude, species) |>  # choose columns to keep
  collect()
```

```
## # A tibble: 21,984 × 3
##    eventDate decimalLatitude species              
##    <dttm>              <dbl> <chr>                
##  1 NA                  -38.2 Eolophus roseicapilla
##  2 NA                  -38.2 Eolophus roseicapilla
##  3 NA                  -37.0 Eolophus roseicapilla
##  4 NA                  -37.7 Eolophus roseicapilla
##  5 NA                  -35.6 Eolophus roseicapilla
##  6 NA                  -31.1 Eolophus roseicapilla
##  7 NA                  -38.2 Eolophus roseicapilla
##  8 NA                  -36.8 Eolophus roseicapilla
##  9 NA                  -38.3 Eolophus roseicapilla
## 10 NA                  -36.8 Eolophus roseicapilla
## # ℹ 21,974 more rows
```

This works because many of the functions in `dplyr` are "generic", meaning
it is possible to write extensions that apply them to new object classes. 
In our case, `galah_call()` creates a new object class called a 
`data_request` for which we have written new extensions. This means that galah 
will not interfere with your use of `filter()` and friends on your tibbles.
Supported `dplyr` verbs that modify queries are as follows:

- `arrange.data_request()`
- `count.data_request()`
- `distinct.data_request()`
- `filter.data_request()`
- `group_by.data_request()`
- `select.data_request()`
- `slice_head.data_request()`

Additional verbs are: 

- `apply_profile()`
- `geolocate()` or `st_crop.data_request()`
- `identify.data_request()`
- `unnest()`

Three other `dplyr` functions are supported to conclude a pipe:

- `collapse.data_request()` converts the `request` object to a `query`. This allows users to inspect  
   their API calls before they are sent. Depending on the request, this function
   may also call 'supplementary' APIs to collect required information,
   such as Taxon Concept Identifiers or field names.
- `compute.data_request()` is intended to send the query in question to the requested API 
   for processing. In practice, only occurrence queries distinguish between
   posting a query and retrieving the results, meaning that in all other cases, 
   `compute()` simply converts the `query` to a new class (`computed_query`).
- `collect.data_request()` retrieves the requested data into your workspace, returning a 
  `tibble`.

It is good practice to download your data in as few steps as possible,
to minimize impacts on the server, and to ensure you can get a single
DOI for your data. See the 
[download data reproducibly](download-data-reproducibly.html) vignette 
for details.

# Finding information

Building queries using `filter()` requires that you know two things:

- what **fields** (columns) are present in the dataset you are searching
- what **values** exist for those fields

Finding this information requires looking for metadata:


``` r
request_metadata() |>
  collect()
```

```
## # A tibble: 639 × 3
##    id                  description               type  
##    <chr>               <chr>                     <chr> 
##  1 abcdTypeStatus      <NA>                      fields
##  2 acceptedNameUsage   Accepted name             fields
##  3 acceptedNameUsageID Accepted name             fields
##  4 accessRights        Access rights             fields
##  5 annotationsDoi      <NA>                      fields
##  6 annotationsUid      Referenced by publication fields
##  7 assertionUserId     Assertions by user        fields
##  8 assertions          Record issues             fields
##  9 assertionsCount     <NA>                      fields
## 10 associatedMedia     Associated Media          fields
## # ℹ 629 more rows
```

You can browser this tibble using `View()` or search it using `filter()`.
Once you have found a field that you want to include in your query, you 
can find values for that field using `unnest()`:


``` r
request_metadata() |>
  filter(fields == "cl22") |>
  unnest() |>
  collect()
```

```
## # A tibble: 11 × 1
##    cl22                        
##    <chr>                       
##  1 New South Wales             
##  2 Victoria                    
##  3 Queensland                  
##  4 South Australia             
##  5 Western Australia           
##  6 Northern Territory          
##  7 Tasmania                    
##  8 Australian Capital Territory
##  9 Macquarie Island            
## 10 Coral Sea Islands           
## 11 Ashmore and Cartier Islands
```

Different types of metadata are available; see `?request_metadata` for
a full list.

# Wrapper functions

While `dplyr` syntax is very flexible, there are cases where it is easier 
to simply say the sort of data you want, rather than create a full database
query to implement it. For this reason, several common use cases have
their own wrapper functions.

The `atlas_` family of functions act like `collect()`, but enforce
a particular type of data to be returned, such as record counts:


``` r
galah_call() |>
  filter(year == 2025) |>
  atlas_counts()   # note no need for a `count()` function
```

```
## # A tibble: 1 × 1
##     count
##     <int>
## 1 8989765
```

Or occurrences:


``` r
galah_call() |>
  identify("Eolophus roseicapilla") |>
  filter(year == 2000,
         cl22 == "Australian Capital Territory") |>
  atlas_occurrences() |>
  print(n = 6)
```

```
## # A tibble: 2,032 × 9
##   recordID                             scientificName        taxonConceptID                                                            decimalLatitude decimalLongitude eventDate           basisOfRecord     occurrenceStatus dataResourceName           
##   <chr>                                <chr>                 <chr>                                                                               <dbl>            <dbl> <dttm>              <chr>             <chr>            <chr>                      
## 1 0026d29f-b6ab-4a1d-9c57-6ee12cfde3a0 Eolophus roseicapilla https://biodiversity.org.au/afd/taxa/9b4ad548-8bb3-486a-ab0a-905506c463ea           -35.4             149. 2000-08-07 00:00:00 HUMAN_OBSERVATION PRESENT          Garden Bird Surveys        
## 2 0062d446-007b-4164-ac4f-ae84297e2578 Eolophus roseicapilla https://biodiversity.org.au/afd/taxa/9b4ad548-8bb3-486a-ab0a-905506c463ea           -35.3             149. 2000-03-10 00:00:00 HUMAN_OBSERVATION PRESENT          BirdLife Australia, Birdata
## 3 00a62ee0-1e08-4114-b0d8-9b7905472d53 Eolophus roseicapilla https://biodiversity.org.au/afd/taxa/9b4ad548-8bb3-486a-ab0a-905506c463ea           -35.2             149. 2000-01-29 00:00:00 HUMAN_OBSERVATION PRESENT          Garden Bird Surveys        
## 4 00ab2f4d-326f-4b01-9a8a-1a10c1f77e3c Eolophus roseicapilla https://biodiversity.org.au/afd/taxa/9b4ad548-8bb3-486a-ab0a-905506c463ea           -35.4             149. 2000-09-25 00:00:00 HUMAN_OBSERVATION PRESENT          Garden Bird Surveys        
## 5 00ae4631-ea59-44ec-b8f8-4377b6b3b3ef Eolophus roseicapilla https://biodiversity.org.au/afd/taxa/9b4ad548-8bb3-486a-ab0a-905506c463ea           -35.3             149. 2000-02-12 00:00:00 HUMAN_OBSERVATION PRESENT          BirdLife Australia, Birdata
## 6 00b6c8ec-e7b9-4d9f-9638-d962b1b4acfa Eolophus roseicapilla https://biodiversity.org.au/afd/taxa/9b4ad548-8bb3-486a-ab0a-905506c463ea           -35.2             149. 2000-02-05 00:00:00 HUMAN_OBSERVATION PRESENT          Garden Bird Surveys        
## # ℹ 2,026 more rows
```

`atlas_species()` replaces the need for `distinct()` call, while `atlas_media()`
is a shortcut to a complex workflow that incorporates both data and metadata
calls; see the [downloading images and sounds](downloading_images_and_sounds.html)
vignette for details.

Finally, metadata calls can be made more efficiently using the `show_all()` 
and `show_values()` functions; see the 
[look up information](lookup_up_information.html) vignette for details.

